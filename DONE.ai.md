# Plan for Auto-Testing Framework using GitHub Actions

This plan outlines the steps to create a robust automated testing framework using GitHub Actions, particularly for a Command Line Interface (CLI) tool that scaffolds projects.

## 1. Define Testing Strategy

- **Identify Test Types:** Determine the necessary types of tests:
  - **Unit Tests:** For individual functions/modules of the CLI.
  - **Integration Tests:** For interactions between CLI components.
  - **End-to-End (E2E) Tests:** For the complete CLI workflow, from command execution to validating the scaffolded project.
- **Prioritize Critical Paths:** Focus on testing core functionalities, common user scenarios, and critical CLI options/flags.
- **CLI Scaffolding Specifics:**
  - Test CLI execution with a matrix of different option combinations.
  - Validate the integrity of the scaffolded project:
    - Can it install dependencies?
    - Can it build successfully?
    - Can it run basic commands (e.g., linting, its own tests)?
    - Are configuration files generated correctly?

## 2. Set Up Core CI Workflow (e.g., `.github/workflows/ci.yml`)

- **Triggers:** Run on `push` to main branches and all `pull_request` events.
- **Jobs:**
  - **Linting & Formatting:**
    - Tools: ESLint, Prettier, Biome, etc. (using pnpm as placeholder)
    - Purpose: Enforce code style and catch syntax errors early.
    - Example commands: `pnpm lint`, `pnpm format:check`.
  - **Type Checking (if applicable, e.g., TypeScript):**
    - Tool: TypeScript Compiler (`tsc`).
    - Purpose: Catch type errors.
    - Example command: `pnpm typecheck` or `tsc --noEmit`.
  - **CLI Build:**
    - Purpose: Ensure the CLI tool itself can be successfully compiled/built.
    - Example command: `pnpm build:cli` (or project-specific build command).
  - **Unit & Integration Tests (if implemented):**
    - Tools: Jest, Vitest, Mocha, etc.
    - Purpose: Test individual CLI components and their interactions.
    - Example command: `pnpm test:unit`.
- **Note:** Created `.github/workflows/ci.yml` with basic structure for linting, type checking, and CLI build. Unit/integration tests are placeholder. Assumed pnpm and Node.js v20, these might need adjustment based on the actual project.

## 3. Develop E2E Testing Workflow (e.g., `.github/workflows/e2e.yml`)

- **Triggers:**
  - Run on `pull_request` events targeting CLI source code paths (and the E2E workflow file itself).
  - Allow manual trigger via `workflow_dispatch`.
  - Placeholder for scheduled runs (e.g., nightly).
- **Matrix Strategy (for varied CLI options):**
  - Initial matrix for `os` and a placeholder `feature` option.
  - Comments included for expanding with more CLI options like frameworks or package managers.
- \*\*E2E Job Steps (for each matrix combination):
  1.  **Setup Environment:**
      - Checkout repository code (`actions/checkout`).
      - Set up Node.js v20 with pnpm caching (`actions/setup-node`).
      - Install project dependencies (`pnpm install`).
  2.  **Build CLI:**
      - Included step `pnpm build:cli` (can be optimized later with artifacts).
  3.  **Scaffold Test Project:**
      - Executes the CLI with current matrix options into a `temp-scaffolded-project` directory.
      - Uses placeholder CLI command `node ./cli/dist/index.js ./temp-scaffolded-project --feature=${{ matrix.feature }} --CI --noGit`.
  4.  **Validate Scaffolded Project:**
      - Placeholder steps to `cd` into the project, install deps, build, test, lint, and verify files.
      - Commands are commented out and need to be adapted to the specific scaffolded project's structure and package manager.
- **Note:** Created `.github/workflows/e2e.yml` with the above structure. The validation steps are placeholders and will require specific commands tailored to the output of the CLI tool.

## 4. Templating Strategy (for CLI Scaffolding)

- **Base Template:**
  - Location: e.g., `templates/base/` or `cli/templates/base/`.
  - Contents: Core files, directories, and configurations common to all projects generated by the CLI.
- **Optional Features/Extras Templates:**
  - Location: e.g., `templates/extras/` or `cli/templates/extras/`.
  - Structure: Subdirectories for each optional feature (e.g., `templates/extras/tailwind/`, `templates/extras/drizzle/`).
  - Contents: Files specific to those optional features.
- **Programmatic Scaffolding Logic:**
  - Implement "installer" scripts or functions (e.g., in `cli/src/installers/`).
  - Responsibilities:
    - Copy files from the base template.
    - Conditionally copy or modify files from "extras" templates based on user CLI options.
    - Programmatically update `package.json` (add dependencies, scripts).
    - Generate or modify configuration files (e.g., `vite.config.js`, `.eslintrc.js`, `tailwind.config.js`).
    - Handle file merges or transformations if necessary.
- **Note:** This section outlines the recommended internal structure for the CLI tool to support flexible and testable scaffolding of projects with various optional features. It's a guideline for the CLI's own architecture rather than a direct CI setup step. Adhering to this strategy will simplify E2E testing across different feature combinations.

## 5. Reusable Workflows / Composite Actions (Optional)

- **Purpose:** To DRY (Don't Repeat Yourself) common steps across multiple jobs or workflows.
- **Implementation:**
  - Created a composite action at `.github/actions/setup/action.yml`.
  - This action handles: Node.js setup, pnpm setup, pnpm store caching, and dependency installation (`pnpm install --frozen-lockfile`).
  - It accepts `node-version`, `pnpm-version`, and `cache-key-prefix` as inputs.
- **Usage:**
  - Updated `ci.yml` and `e2e.yml` to use this composite action for their setup steps, replacing individual setup for Node, pnpm, and dependency installation.

## 6. Secrets and Environment Variables

- **Secrets:** Use GitHub encrypted secrets (`secrets.GITHUB_TOKEN`, custom secrets) for any sensitive data needed during tests (e.g., API keys for external services, private package registry tokens).
- **Environment Variables:** Use environment variables for non-sensitive configuration that might vary between test runs or environments.
- **Note:** This is a guideline for managing sensitive and configurable data within GitHub Actions. Specific secrets and variables will need to be configured in the repository settings as required by the tests or CLI tool.

## 7. Artifacts and Reporting

- **Test Reports:** If test runners generate reports (e.g., JUnit XML, HTML reports), upload them as artifacts for easier debugging.
  - Action: `actions/upload-artifact`.
- **Build Artifacts:** Upload build outputs (e.g., the built CLI, scaffolded project examples) if useful for debugging or downstream processes.
- **Note:** This section provides best practices for surfacing test results and build outputs. The `actions/upload-artifact` action can be added to workflow jobs (e.g., in `e2e.yml` after validation steps, or in `ci.yml` for the CLI build) as needed when actual test runners and detailed build processes are in place.

## 8. Notifications (Optional)

- Configure notifications (e.g., Slack, email) for workflow failures or successes using marketplace actions or GitHub's built-in notification settings.
- **Note:** This is an optional enhancement for visibility into CI/CD pipeline status. Implementation will depend on the desired notification channels and can be added later.

## 9. Documentation

- **README/Contributing Guide:** Document the testing framework, how to run tests locally, how to add new tests, and common troubleshooting steps.
- **Workflow Comments:** Add comments within the YAML workflow files to explain complex steps or configurations.
- **Note:** Ongoing documentation is crucial. Comments have been added to the created YAML files. The `README.md` or a `CONTRIBUTING.md` should be updated with details about this CI setup and how to use/extend it. This `DONE.ai.md` file serves as an initial record of the setup process.
